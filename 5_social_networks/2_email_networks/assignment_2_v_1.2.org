#+TITLE: Network Connectivity v 1.2

In this assignment you will go through the process of importing and analyzing an internal email communication network between employees of a mid-sized manufacturing company. 
Each node represents an employee and each directed edge between two nodes represents an individual email. The left node represents the sender and the right node represents the recipient.

* Imports

#+BEGIN_SRC ipython :session connectivity :results none
# python standard library
from collections import defaultdict

# from pypi
import networkx
import pandas
import seaborn
#+END_SRC

#+BEGIN_SRC ipython :session connectivity :results none
% matplotlib inline
seaborn.set_style("whitegrid")
#+END_SRC

* The Data

#+BEGIN_SRC shell
head email_network.txt
#+END_SRC

#+RESULTS:
| #Sender | Recipient |       time |
|       1 |         2 | 1262454010 |
|       1 |         3 | 1262454010 |
|       1 |         4 | 1262454010 |
|       1 |         5 | 1262454010 |
|       1 |         6 | 1262454010 |
|       1 |         7 | 1262454010 |
|       1 |         8 | 1262454010 |
|       1 |         9 | 1262454010 |
|       1 |        10 | 1262454010 |

#+BEGIN_SRC ipython :session connectivity :results output :noweb-ref data
email_network = pandas.read_table('email_network.txt', dtype={"#Sender": str, "Recipient": str})
print(email_network.head())
#+END_SRC

#+RESULTS:
:   #Sender Recipient        time
: 0       1         2  1262454010
: 1       1         3  1262454010
: 2       1         4  1262454010
: 3       1         5  1262454010
: 4       1         6  1262454010

* 1 - Load the Directed Multigraph
Using networkx, load up the directed multigraph from `email_network.txt`. Make sure the node names are strings.

*This function should return a directed multigraph networkx graph.*

#+BEGIN_SRC ipython :session connectivity :results none
def answer_one():
    """Loads the email-network graph

    Returns:
     networkx.MultiDiGraph: the graph of the email network
    """
    email_network = pandas.read_table('email_network.txt', dtype={"#Sender": str, "Recipient": str})
    # according to the notes online, the grade doesn't work with data
    # defined outside of the function
    pandas.read_table('email_network.txt', dtype={"#Sender": str, "Recipient": str})
    # there's a bug in networkx loading MultiDiGraphs from pandas data-frames
    # so this is a work-around
    graph = networkx.MultiDiGraph()
    tuples = [(sender, recipient, {"time": time})
              for (sender, recipient, time) in email_network.values]
    graph.add_edges_from(tuples)
    return graph    
#+END_SRC

#+BEGIN_SRC ipython :session connectivity :results output
one = answer_one()
print(networkx.info(one))
assert type(one) is networkx.MultiDiGraph
#+END_SRC

#+RESULTS:
: Name: 
: Type: MultiDiGraph
: Number of nodes: 167
: Number of edges: 82927
: Average in degree: 496.5689
: Average out degree: 496.5689

* 2 - Count of Employees and Emails

How many employees and emails are represented in the graph from Question 1?
*This function should return a tuple (#employees, #emails).*

#+BEGIN_SRC ipython :session connectivity :results none
def answer_two():
    """Counts the number of employees and emails

    Returns:
     tuple: count of employees, count of emails
    """
    one = answer_one()
    return (one.order(), one.size())
#+END_SRC

Each node in the graph is an employee and each edge is an email sent from one employee to another.

#+BEGIN_SRC ipython :session connectivity :results none
employees, emails = answer_two()
assert employees == 167
assert emails == 82927
#+END_SRC

* 3 - Information Routes
** Part 1. Assume that information in this company can only be exchanged through email.
   When an employee sends an email to another employee, a communication channel has been created, allowing the sender to provide information to the receiver, but not vice versa. 

   Based on the emails sent in the data, is it possible for information to go from every employee to every other employee?
** Part 2. Now assume that a communication channel established by an email allows information to be exchanged both ways. 
   Based on the emails sent in the data, is it possible for information to go from every employee to every other employee?
   *This function should return a tuple of bools (part1, part2).*

#+BEGIN_SRC ipython :session connectivity :results none
def answer_three():
    """decides connectivity based on emails

    First: Assume communication is not necessarily allowed both ways - 
    based on data, can every employee contact each other?

    Second: Assume any contact means there's two way communication. 
    Can every employee be contacted?

    Returns:
     tuple: (every employee contacted every other employee, every employee contacted once)
    """
    emails = answer_one()
    return networkx.is_strongly_connected(emails), networkx.is_weakly_connected(emails)    
#+END_SRC

#+BEGIN_SRC ipython :session connectivity :results output
print(answer_three())
#+END_SRC

#+RESULTS:
: (False, True)

* 4 - Largest Weakly Connected Component
  How many nodes are in the largest (in terms of nodes) weakly connected component?
  *This function should return an int.*

#+BEGIN_SRC ipython :session connectivity :results none
def answer_four():
    """Count of nodes in the largest weakly connected component"""
    one = answer_one()
    return len(max(networkx.weakly_connected_component_subgraphs(one), key=len).nodes())
#+END_SRC

According to [[https://en.wikipedia.org/wiki/Connectivity_%28graph_theory%29#Definitions_of_components.2C_cuts_and_connectivity][Wikipedia]], a directed graph is weakly connected if replacing every directed edge with an undirected one creates a connected graph, so if the undirected graph in the next section is a connected graph, then the entire email graph is weakly connected.

#+BEGIN_SRC ipython :session connectivity :results output
print(answer_four())
undirected = one.to_undirected()
print(networkx.is_connected(undirected))
#+END_SRC

#+RESULTS:
: 167
: True

* 5 - Nodes in Largest Strongly Connected Component
How many nodes are in the largest (in terms of nodes) strongly connected component?

*This function should return an int*
#+BEGIN_SRC ipython :session connectivity :results none
def answer_five():
    """size of largest strongly connected component

    Returns:
     int: number of nodes in largest strongly connected component
    """
    return len(max(networkx.strongly_connected_components(one), key=len))
#+END_SRC

#+BEGIN_SRC ipython :session connectivity :results output
print(answer_five())
#+END_SRC

#+RESULTS:
: 126


* 6 - Subgraph nodes of largest strongly connected component
  Using the NetworkX function strongly_connected_component_subgraphs, find the subgraph of nodes in a largest strongly connected component. 
  Call this graph G_sc.

  *This function should return a networkx MultiDiGraph named G_sc.*

#+BEGIN_SRC ipython :session connectivity :results none
def answer_six():
    """the sub-graph of the largest strongly connected component
    
    Returns: 
     networkx.MultiDiGraph: largest strongly connected component
    """
    one = answer_one()
    return max(networkx.algorithms.strongly_connected_component_subgraphs(one),
               key=len)
#+END_SRC

#+BEGIN_SRC ipython :session connectivity :results none
strongly_connected = answer_six()
assert len(strongly_connected.nodes()) == answer_five()
assert type(strongly_connected) is networkx.MultiDiGraph
#+END_SRC


* 7 - Average distance between nodes
  What is the average distance between nodes in G_sc?

  *This function should return a float.*

#+BEGIN_SRC ipython :session connectivity :results none
def answer_seven():
    """average distance between nodes"""
    strongly_connected = answer_six()
    return networkx.average_shortest_path_length(strongly_connected)
#+END_SRC

#+BEGIN_SRC ipython :session connectivity :results output
average_distance = answer_seven()
print(average_distance)
assert type(average_distance) is float
#+END_SRC

#+RESULTS:
: 1.6461587301587302

* 8 - Largest Possible Distance Between Two Employees
  What is the largest possible distance between two employees in G_sc?
  *This function should return an int.*

#+BEGIN_SRC ipython :session connectivity :results none
def answer_eight():
    """Largest possible distance between employees"""
    strongly_connected = answer_six()
    return networkx.diameter(strongly_connected)
#+END_SRC

#+BEGIN_SRC ipython :session connectivity :results output
largest_distance = answer_eight()
print(largest_distance)
assert type(largest_distance) is int
#+END_SRC

#+RESULTS:
: 3


* 9 - Nodes With Eccentricity Equal to the Diameter
  What is the set of nodes in G_sc with eccentricity equal to the diameter?

  *This function should return a set of the node(s).*

#+BEGIN_SRC ipython :session connectivity :results none
def answer_nine():
    """Nodes with eccentricity equal to diameter"""
    strongly_connected = answer_six()
    return set(networkx.periphery(strongly_connected))
#+END_SRC

#+BEGIN_SRC ipython :session connectivity :results output
nodes = answer_nine()
print(nodes)
assert type(nodes) is set
#+END_SRC

#+RESULTS:
: {'134', '97', '129'}


* 10 - Eccentricity Equal to the Radius
  What is the set of node(s) in G_sc with eccentricity equal to the radius?

  *This function should return a set of the node(s).*

#+BEGIN_SRC ipython :session connectivity :results none
def answer_ten():
    """Nodes with eccentricity equal to the radius"""
    strongly_connected = answer_six()
    return set(networkx.center(strongly_connected))
#+END_SRC

#+BEGIN_SRC ipython :session connectivity :results output
radius_eccentricity = answer_ten()
print(radius_eccentricity)
assert type(radius_eccentricity) is set
#+END_SRC

#+RESULTS:
: {'38'}


* 11 - Connected to Most Nodes with Diameter
  Which node in G_sc is connected to the most other nodes by a shortest path of length equal to the diameter of G_sc?

  How many nodes are connected to this node?

 *This function should return a tuple (name of node, number of satisfied connected nodes).*

#+BEGIN_SRC ipython :session connectivity :results none
def answer_eleven():
    """node with most shortest paths to other peripheral nodes"""
    candidates = networkx.periphery(strongly_connected)
    outcomes = defaultdict(int)
    for candidate_1 in candidates:
        for candidate_2 in candidates:
            if (candidate_1 != candidate_2
                and networkx.has_path(strongly_connected,
                                      candidate_1,
                                      candidate_2)):
                outcomes[candidate_1] += len(list(networkx.all_shortest_paths(strongly_connected,
                                                                              candidate_1,
                                                                              candidate_2)))
    node = max(outcomes, key=lambda key: outcomes[key])
    return node, outcomes[node]
#+END_SRC

#+BEGIN_SRC ipython :session connectivity :results output
name,  number = answer_eleven()
print(name, number)
assert type(name) is str
assert type(number) is int
#+END_SRC

#+RESULTS:
: 129 15

* 12 - Prevent Communication to Most Connected

  Suppose you want to prevent communication from flowing to the node that you found in the previous question from any node in the center of G_sc, what is the smallest number of nodes you would need to remove from the graph (you're not allowed to remove the node from the previous question or the center nodes)? 

 *This function should return an integer.*

#+BEGIN_SRC ipython :session connectivity :results none
def answer_twelve():
    """Smallest number of nodes to remove node from graph"""
    node, count = answer_eleven()    
    center = networkx.center(strongly_connected)
    remove = [networkx.node_connectivity(strongly_connected, node, other) for other in center]
    return max(remove)
#+END_SRC

#+BEGIN_SRC ipython :session connectivity :results output
print(answer_twelve())
#+END_SRC

#+RESULTS:
: 5

* 13 - Undirected Strongly Connected Graph

Construct an undirected graph G_un using G_sc (you can ignore the attributes).

 *This function should return a networkx Graph.*

#+BEGIN_SRC ipython :session connectivity :results none
def answer_thirteen():
    """undirected version of strongly connected graph"""
    return answer_six().to_undirected()
#+END_SRC

#+BEGIN_SRC ipython :session connectivity :ipyfile /tmp/strongly_undirected.png :exports both :results raw drawer
graph = answer_thirteen()
assert not graph.is_directed()
networkx.draw(graph, with_labels=True)
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:/tmp/strongly_undirected.png]]
:END:

* 14 - Transitivity and Average Clustering Coefficient
  What is the transitivity and average clustering coefficient of graph G_un?

  *This function should return a tuple (transitivity, avg clustering).*

#+BEGIN_SRC ipython :session connectivity :results none
def answer_fourteen():
    graph = answer_thirteen()
    graph = networkx.Graph(graph)
    return networkx.transitivity(graph), networkx.average_clustering(graph)
#+END_SRC

#+BEGIN_SRC ipython :session connectivity :results output
print(answer_fourteen())
#+END_SRC

#+RESULTS:
: (0.570111160700385, 0.6975272437231418)
* Graded
** Correct
Function answer_one was answered correctly, 0.09 points were awarded.
Function answer_two was answered correctly, 0.07 points were awarded.
Function answer_three was answered correctly, 0.07 points were awarded.
Function answer_four was answered correctly, 0.07 points were awarded.
Function answer_five was answered correctly, 0.07 points were awarded.
Function answer_six was answered correctly, 0.07 points were awarded.
Function answer_seven was answered correctly, 0.07 points were awarded.
Function answer_eight was answered correctly, 0.07 points were awarded.
Function answer_nine was answered correctly, 0.07 points were awarded.
Function answer_ten was answered correctly, 0.07 points were awarded.
Function answer_twelve was answered correctly, 0.07 points were awarded.
Function answer_fourteen was answered correctly, 0.07 points were awarded.
** Incorrect
Function answer_eleven was answered incorrectly, 0.07 points were not awarded.
Function answer_thirteen was answered incorrectly, 0.07 points were not awarded.
